{"ast":null,"code":"// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which\n// does not have browser (or, by proxy, React-Native) support.\nconst Buffer = require('buffer/').Buffer;\n\nconst constants = require('./constants');\n\nconst keccak256 = require('js-sha3').keccak256;\n\nconst rlp = require('rlp-browser');\n\nconst secp256k1 = require('secp256k1');\n\nexports.buildEthereumMsgRequest = function (input) {\n  if (!input.payload || !input.protocol || !input.signerPath) throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');\n  const req = {\n    schema: constants.signingSchema.ETH_MSG,\n    payload: null,\n    input,\n    // Save the input for later\n    msg: null // Save the buffered message for later\n\n  };\n\n  if (input.protocol === 'signPersonal') {\n    const L = (input.signerPath.length + 1) * 4 + constants.ETH_MSG_MAX_SIZE + 4;\n    let off = 0;\n    req.payload = Buffer.alloc(L);\n    req.payload.writeUInt8(constants.ethMsgProtocol.SIGN_PERSONAL, 0);\n    off += 1;\n    req.payload.writeUInt32LE(input.signerPath.length, off);\n    off += 4;\n\n    for (let i = 0; i < input.signerPath.length; i++) {\n      req.payload.writeUInt32LE(input.signerPath[i], off);\n      off += 4;\n    } // Write the payload buffer. The payload can come in either as a buffer or as a string\n\n\n    let payload = input.payload; // Determine if this is a hex string\n\n    let displayHex = false;\n\n    if (typeof input.payload === 'string') {\n      if (input.payload.slice(0, 2) === '0x') {\n        payload = ensureHexBuffer(input.payload);\n        displayHex = false === isASCII(payload.toString());\n      } else {\n        payload = Buffer.from(input.payload);\n      }\n    } else if (typeof input.displayHex === 'boolean') {\n      // If this is a buffer and the user has specified whether or not this\n      // is a hex buffer with the optional argument, write that\n      displayHex = input.displayHex;\n    } // Make sure we didn't run past the max size\n\n\n    if (payload.length > constants.ETH_MSG_MAX_SIZE) throw new Error(`Your payload is ${payload.length} bytes, but can only be a maximum of ${constants.ETH_MSG_MAX_SIZE}`); // Write the payload and metadata into our buffer\n\n    req.msg = payload;\n    req.payload.writeUInt8(displayHex, off);\n    off += 1;\n    req.payload.writeUInt16LE(payload.length, off);\n    off += 2;\n    payload.copy(req.payload, off);\n    return req;\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n};\n\nexports.validateEthereumMsgResponse = function (res, req) {\n  const {\n    signer,\n    sig\n  } = res;\n  const {\n    input,\n    msg\n  } = req;\n\n  if (input.protocol === 'signPersonal') {\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${msg.length.toString()}`, 'utf-8');\n    return addRecoveryParam(Buffer.concat([prefix, msg]), sig, signer);\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n};\n\nexports.buildEthereumTxRequest = function (data) {\n  try {\n    let {\n      chainId = 1\n    } = data;\n    const {\n      signerPath\n    } = data;\n    if (typeof chainId !== 'number') chainId = chainIds[chainId];\n    if (!chainId) throw new Error('Unsupported chain name');else if (!signerPath || signerPath.length !== 5) throw new Error('Please provider full signer path (`signerPath`)');\n    const useEIP155 = eip155[chainId]; // Hack for metamask, which sends value=null for 0 ETH transactions\n\n    if (!data.value) data.value = 0; //--------------\n    // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING\n    //--------------\n    // Ensure all fields are 0x-prefixed hex strings\n\n    const rawTx = []; // Build the transaction buffer array\n\n    const nonceBytes = ensureHexBuffer(data.nonce);\n    const gasPriceBytes = ensureHexBuffer(data.gasPrice);\n    const gasLimitBytes = ensureHexBuffer(data.gasLimit);\n    const toBytes = ensureHexBuffer(data.to);\n    const valueBytes = ensureHexBuffer(data.value);\n    const dataBytes = ensureHexBuffer(data.data);\n    rawTx.push(nonceBytes);\n    rawTx.push(gasPriceBytes);\n    rawTx.push(gasLimitBytes);\n    rawTx.push(toBytes);\n    rawTx.push(valueBytes);\n    rawTx.push(dataBytes); // Add empty v,r,s values\n\n    if (useEIP155 === true) {\n      rawTx.push(ensureHexBuffer(chainId)); // v\n\n      rawTx.push(ensureHexBuffer(null)); // r\n\n      rawTx.push(ensureHexBuffer(null)); // s\n    } //--------------\n    // 2. BUILD THE LATTICE REQUEST PAYLOAD\n    //--------------\n    // Here we take the data from the raw transaction and serialize it into a buffer that\n    // can be consumed by the Lattice firmware. Note that each field has a 4-byte prefix\n    // field indicating how many non-zero bytes are being used in the field. If we use fewer\n    // than the max number of bytes for a given field, we still need to offset by the field\n    // width so that the data may be unpacked into a struct on the Lattice side.\n    //\n    // Fields:\n    // 4-byte pathDepth header\n    // 5x 4-byte path indices = 20\n    // 1 byte bool (EIP155)\n    // 4 byte nonce (+4byte prefix)\n    // 8 byte gasPrice (+4byte prefix)\n    // 4 byte gasLimit (+4byte prefix)\n    // 20 byte to address (+4byte prefix)\n    // 32 byte value (+4byte prefix)\n    // 1024 data bytes (+4byte prefix)\n    // 1 byte chainID (a.k.a. `v`) (+4byte prefix)\n\n\n    const txReqPayload = Buffer.alloc(1146);\n    let off = 0; // 1. EIP155 switch and chainID\n    //------------------\n\n    txReqPayload.writeUInt8(Number(useEIP155), off);\n    off++;\n    txReqPayload.writeUInt8(Number(chainId), off);\n    off++; // 2. BIP44 Path\n    //------------------\n    // First write the number of indices in this path (will probably always be 5, but\n    // we want to keep this extensible)\n\n    txReqPayload.writeUInt32LE(signerPath.length, off);\n    off += 4;\n\n    for (let i = 0; i < signerPath.length; i++) {\n      txReqPayload.writeUInt32LE(signerPath[i], off);\n      off += 4;\n    } // 3. ETH TX request data\n    //------------------\n\n\n    txReqPayload.writeUInt32BE(data.nonce, off);\n    off += 4;\n    writeUInt64BE(data.gasPrice, txReqPayload, off);\n    off += 8;\n    txReqPayload.writeUInt32BE(data.gasLimit, off);\n    off += 4;\n    toBytes.copy(txReqPayload, off);\n    off += 20; // Place the value (a BE number) in an offset such that it\n    // can be interpreted as a number\n\n    const valueOff = off + 32 - valueBytes.length;\n    valueBytes.copy(txReqPayload, valueOff);\n    off += 32; // Ensure data field isn't too long\n\n    if (dataBytes && dataBytes.length > constants.ETH_DATA_MAX_SIZE) {\n      return {\n        err: `Data field too large (must be <=${constants.ETH_DATA_MAX_SIZE} bytes)`\n      };\n    } // Data\n\n\n    txReqPayload.writeUInt16BE(dataBytes.length, off);\n    off += 2;\n    dataBytes.copy(txReqPayload, off);\n    off += 1024;\n    return {\n      rawTx,\n      payload: txReqPayload,\n      schema: constants.signingSchema.ETH_TRANSFER,\n      // We will use eth transfer for all ETH txs for v1 \n      chainId,\n      useEIP155,\n      signerPath\n    };\n  } catch (err) {\n    return {\n      err: err.message\n    };\n  }\n}; // From ethereumjs-util\n\n\nfunction stripZeros(a) {\n  let first = a[0];\n\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n\n  return a;\n} // Given a 64-byte signature [r,s] we need to figure out the v value\n// and attah the full signature to the end of the transaction payload\n\n\nexports.buildEthRawTx = function (tx, sig, address, useEIP155 = true) {\n  // RLP-encode the data we sent to the lattice\n  const rlpEncoded = rlp.encode(tx.rawTx);\n  const newSig = addRecoveryParam(rlpEncoded, sig, address, tx.chainId, useEIP155); // Use the signature to generate a new raw transaction payload\n\n  const newRawTx = tx.rawTx.slice(0, 6);\n  newRawTx.push(Buffer.from(newSig.v.toString(16), 'hex')); // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros\n  // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187\n\n  newRawTx.push(stripZeros(newSig.r));\n  newRawTx.push(stripZeros(newSig.s));\n  return rlp.encode(newRawTx).toString('hex');\n}; // Attach a recovery parameter to a signature by brute-forcing ECRecover\n\n\nfunction addRecoveryParam(payload, sig, address, chainId, useEIP155) {\n  try {\n    // Rebuild the keccak256 hash here so we can `ecrecover`\n    const hash = new Uint8Array(Buffer.from(keccak256(payload), 'hex'));\n    sig.v = 27; // Fix signature componenet lengths to 32 bytes each\n\n    const r = fixLen(sig.r, 32);\n    sig.r = r;\n    const s = fixLen(sig.s, 32);\n    sig.s = s; // Calculate the recovery param\n\n    const rs = new Uint8Array(Buffer.concat([r, s]));\n    let pubkey = secp256k1.ecdsaRecover(rs, sig.v - 27, hash, false).slice(1); // If the first `v` value is a match, return the sig!\n\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      if (useEIP155 === true) sig.v = updateRecoveryParam(sig.v, chainId);\n      return sig;\n    } // Otherwise, try the other `v` value\n\n\n    sig.v = 28;\n    pubkey = secp256k1.ecdsaRecover(rs, sig.v - 27, hash, false).slice(1);\n\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      if (useEIP155 === true) sig.v = updateRecoveryParam(sig.v, chainId);\n      return sig;\n    } else {\n      // If neither is a match, we should return an error\n      throw new Error('Invalid Ethereum signature returned.');\n    }\n  } catch (err) {\n    throw new Error(err);\n  }\n}\n\nexports.addRecoveryParam = addRecoveryParam; // Convert an RLP-serialized transaction (plus signature) into a transaction hash\n\nexports.hashTransaction = function (serializedTx) {\n  return keccak256(Buffer.from(serializedTx, 'hex'));\n}; // Ensure a param is represented by a buffer\n\n\nfunction ensureHexBuffer(x) {\n  if (x === null || x === 0) return Buffer.alloc(0);else if (Buffer.isBuffer(x)) x = x.toString('hex');\n  if (typeof x === 'number') x = `${x.toString(16)}`;else if (typeof x === 'string' && x.slice(0, 2) === '0x') x = x.slice(2);\n  if (x.length % 2 > 0) x = `0${x}`;\n  return Buffer.from(x, 'hex');\n} // Returns address string given public key buffer\n\n\nfunction pubToAddrStr(pub) {\n  return keccak256(pub).slice(-40);\n}\n\nfunction fixLen(msg, length) {\n  const buf = Buffer.alloc(length);\n\n  if (msg.length < length) {\n    msg.copy(buf, length - msg.length);\n    return buf;\n  }\n\n  return msg.slice(-length);\n}\n\nfunction updateRecoveryParam(v, chainId) {\n  return v + chainId * 2 + 8;\n}\n\nfunction writeUInt64BE(n, buf, off) {\n  if (typeof n === 'number') n = n.toString(16);\n  const preBuf = Buffer.alloc(8);\n  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;\n  const nBuf = Buffer.from(nStr, 'hex');\n  nBuf.copy(preBuf, preBuf.length - nBuf.length);\n  preBuf.copy(buf, off);\n  return preBuf;\n}\n\nfunction isASCII(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\nconst chainIds = {\n  mainnet: 1,\n  roptsten: 3,\n  rinkeby: 4,\n  kovan: 42,\n  goerli: 5\n};\nconst eip155 = {\n  1: true,\n  3: false,\n  4: false,\n  42: true,\n  5: true\n};\nexports.chainIds = chainIds;","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/gridplus-sdk/src/ethereum.js"],"names":["Buffer","require","constants","keccak256","rlp","secp256k1","exports","buildEthereumMsgRequest","input","payload","protocol","signerPath","Error","req","schema","signingSchema","ETH_MSG","msg","L","length","ETH_MSG_MAX_SIZE","off","alloc","writeUInt8","ethMsgProtocol","SIGN_PERSONAL","writeUInt32LE","i","displayHex","slice","ensureHexBuffer","isASCII","toString","from","writeUInt16LE","copy","validateEthereumMsgResponse","res","signer","sig","prefix","addRecoveryParam","concat","buildEthereumTxRequest","data","chainId","chainIds","useEIP155","eip155","value","rawTx","nonceBytes","nonce","gasPriceBytes","gasPrice","gasLimitBytes","gasLimit","toBytes","to","valueBytes","dataBytes","push","txReqPayload","Number","writeUInt32BE","writeUInt64BE","valueOff","ETH_DATA_MAX_SIZE","err","writeUInt16BE","ETH_TRANSFER","message","stripZeros","a","first","buildEthRawTx","tx","address","rlpEncoded","encode","newSig","newRawTx","v","r","s","hash","Uint8Array","fixLen","rs","pubkey","ecdsaRecover","pubToAddrStr","updateRecoveryParam","hashTransaction","serializedTx","x","isBuffer","pub","buf","n","preBuf","nStr","nBuf","str","test","mainnet","roptsten","rinkeby","kovan","goerli"],"mappings":"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","sourcesContent":["// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which\n// does not have browser (or, by proxy, React-Native) support.\nconst Buffer = require('buffer/').Buffer\nconst constants = require('./constants');\nconst keccak256 = require('js-sha3').keccak256;\nconst rlp = require('rlp-browser');\nconst secp256k1 = require('secp256k1');\n\nexports.buildEthereumMsgRequest = function(input) {\n  if (!input.payload || !input.protocol || !input.signerPath)\n    throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');\n  const req = {\n    schema: constants.signingSchema.ETH_MSG,\n    payload: null,\n    input, // Save the input for later\n    msg: null, // Save the buffered message for later\n  }\n  if (input.protocol === 'signPersonal') {\n    const L = ((input.signerPath.length + 1) * 4) + constants.ETH_MSG_MAX_SIZE + 4;\n    let off = 0;\n    req.payload = Buffer.alloc(L);\n    req.payload.writeUInt8(constants.ethMsgProtocol.SIGN_PERSONAL, 0); off += 1;\n    req.payload.writeUInt32LE(input.signerPath.length, off); off += 4;\n    for (let i = 0; i < input.signerPath.length; i++) {\n      req.payload.writeUInt32LE(input.signerPath[i], off); off += 4;\n    }\n    // Write the payload buffer. The payload can come in either as a buffer or as a string\n    let payload = input.payload;\n    // Determine if this is a hex string\n    let displayHex = false;\n    if (typeof input.payload === 'string') {\n      if (input.payload.slice(0, 2) === '0x') {\n        payload = ensureHexBuffer(input.payload)\n        displayHex = false === isASCII(payload.toString());\n      } else {\n        payload = Buffer.from(input.payload)\n      }\n    } else if (typeof input.displayHex === 'boolean') {\n      // If this is a buffer and the user has specified whether or not this\n      // is a hex buffer with the optional argument, write that\n      displayHex = input.displayHex\n    }\n    // Make sure we didn't run past the max size\n    if (payload.length > constants.ETH_MSG_MAX_SIZE)\n      throw new Error(`Your payload is ${payload.length} bytes, but can only be a maximum of ${constants.ETH_MSG_MAX_SIZE}`);\n    // Write the payload and metadata into our buffer\n    req.msg = payload;\n    req.payload.writeUInt8(displayHex, off); off += 1;\n    req.payload.writeUInt16LE(payload.length, off); off += 2;\n    payload.copy(req.payload, off);\n    return req;\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n}\n\nexports.validateEthereumMsgResponse = function(res, req) {\n  const { signer, sig } = res;\n  const { input, msg } = req;\n  if (input.protocol === 'signPersonal') {\n    const prefix = Buffer.from(\n      `\\u0019Ethereum Signed Message:\\n${msg.length.toString()}`,\n      'utf-8',\n    );\n    return addRecoveryParam(Buffer.concat([prefix, msg]), sig, signer)\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n}\n\nexports.buildEthereumTxRequest = function(data) {\n  try {\n    let { chainId=1 } = data;\n    const { signerPath } = data;\n    if (typeof chainId !== 'number') chainId = chainIds[chainId];\n    if (!chainId) throw new Error('Unsupported chain name');\n    else if (!signerPath || signerPath.length !== 5) throw new Error('Please provider full signer path (`signerPath`)')\n    const useEIP155 = eip155[chainId];\n\n    // Hack for metamask, which sends value=null for 0 ETH transactions\n    if (!data.value)\n      data.value = 0;\n      \n    //--------------\n    // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING\n    //--------------\n\n    // Ensure all fields are 0x-prefixed hex strings\n    const rawTx = [];\n    // Build the transaction buffer array\n    const nonceBytes = ensureHexBuffer(data.nonce);\n    const gasPriceBytes = ensureHexBuffer(data.gasPrice);\n    const gasLimitBytes = ensureHexBuffer(data.gasLimit);\n    const toBytes = ensureHexBuffer(data.to);\n    const valueBytes = ensureHexBuffer(data.value);\n    const dataBytes = ensureHexBuffer(data.data);\n\n    rawTx.push(nonceBytes);\n    rawTx.push(gasPriceBytes);\n    rawTx.push(gasLimitBytes);\n    rawTx.push(toBytes);\n    rawTx.push(valueBytes);\n    rawTx.push(dataBytes);\n    // Add empty v,r,s values\n    if (useEIP155 === true) {\n      rawTx.push(ensureHexBuffer(chainId)); // v\n      rawTx.push(ensureHexBuffer(null));    // r\n      rawTx.push(ensureHexBuffer(null));    // s\n    }\n\n    //--------------\n    // 2. BUILD THE LATTICE REQUEST PAYLOAD\n    //--------------\n\n    // Here we take the data from the raw transaction and serialize it into a buffer that\n    // can be consumed by the Lattice firmware. Note that each field has a 4-byte prefix\n    // field indicating how many non-zero bytes are being used in the field. If we use fewer\n    // than the max number of bytes for a given field, we still need to offset by the field\n    // width so that the data may be unpacked into a struct on the Lattice side.\n    //\n    // Fields:\n    // 4-byte pathDepth header\n    // 5x 4-byte path indices = 20\n    // 1 byte bool (EIP155)\n    // 4 byte nonce (+4byte prefix)\n    // 8 byte gasPrice (+4byte prefix)\n    // 4 byte gasLimit (+4byte prefix)\n    // 20 byte to address (+4byte prefix)\n    // 32 byte value (+4byte prefix)\n    // 1024 data bytes (+4byte prefix)\n    // 1 byte chainID (a.k.a. `v`) (+4byte prefix)\n    const txReqPayload = Buffer.alloc(1146);\n    let off = 0;\n\n    // 1. EIP155 switch and chainID\n    //------------------\n    txReqPayload.writeUInt8(Number(useEIP155), off); off++;\n    txReqPayload.writeUInt8(Number(chainId), off); off++;\n\n    // 2. BIP44 Path\n    //------------------\n    // First write the number of indices in this path (will probably always be 5, but\n    // we want to keep this extensible)\n    txReqPayload.writeUInt32LE(signerPath.length, off); off += 4;\n    for (let i = 0; i < signerPath.length; i++) {\n      txReqPayload.writeUInt32LE(signerPath[i], off); off += 4;\n    }\n\n    // 3. ETH TX request data\n    //------------------\n    txReqPayload.writeUInt32BE(data.nonce, off); off += 4;\n    writeUInt64BE(data.gasPrice, txReqPayload, off); off += 8;\n    txReqPayload.writeUInt32BE(data.gasLimit, off); off += 4;\n    toBytes.copy(txReqPayload, off); off += 20;\n    // Place the value (a BE number) in an offset such that it\n    // can be interpreted as a number\n    const valueOff = off + 32 - valueBytes.length;\n    valueBytes.copy(txReqPayload, valueOff); off += 32;\n    // Ensure data field isn't too long\n    if (dataBytes && dataBytes.length > constants.ETH_DATA_MAX_SIZE) {\n      return { err: `Data field too large (must be <=${constants.ETH_DATA_MAX_SIZE} bytes)` }\n    }\n    // Data\n    txReqPayload.writeUInt16BE(dataBytes.length, off); off += 2;\n    dataBytes.copy(txReqPayload, off); off += 1024;\n\n    return { \n      rawTx,\n      payload: txReqPayload,\n      schema: constants.signingSchema.ETH_TRANSFER,  // We will use eth transfer for all ETH txs for v1 \n      chainId,\n      useEIP155,\n      signerPath,\n    };\n  } catch (err) {\n    return { err: err.message };\n  }\n}\n\n// From ethereumjs-util\nfunction stripZeros(a) {\n  let first = a[0]\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1)\n    first = a[0]\n  }\n  return a\n}\n\n// Given a 64-byte signature [r,s] we need to figure out the v value\n// and attah the full signature to the end of the transaction payload\nexports.buildEthRawTx = function(tx, sig, address, useEIP155=true) {\n  // RLP-encode the data we sent to the lattice\n  const rlpEncoded = rlp.encode(tx.rawTx);\n  const newSig = addRecoveryParam(rlpEncoded, sig, address, tx.chainId, useEIP155);\n  // Use the signature to generate a new raw transaction payload\n  const newRawTx = tx.rawTx.slice(0, 6);\n  newRawTx.push(Buffer.from((newSig.v).toString(16), 'hex'));\n  // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros\n  // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187\n  newRawTx.push(stripZeros(newSig.r));\n  newRawTx.push(stripZeros(newSig.s));\n  return rlp.encode(newRawTx).toString('hex');\n}\n\n// Attach a recovery parameter to a signature by brute-forcing ECRecover\nfunction addRecoveryParam(payload, sig, address, chainId, useEIP155) {\n  try {\n    // Rebuild the keccak256 hash here so we can `ecrecover`\n    const hash = new Uint8Array(Buffer.from(keccak256(payload), 'hex'));\n    sig.v = 27;\n    // Fix signature componenet lengths to 32 bytes each\n    const r = fixLen(sig.r, 32); sig.r = r;\n    const s = fixLen(sig.s, 32); sig.s = s;\n    // Calculate the recovery param\n    const rs = new Uint8Array(Buffer.concat([r, s]));\n    let pubkey = secp256k1.ecdsaRecover(rs, sig.v - 27, hash, false).slice(1)\n    // If the first `v` value is a match, return the sig!\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      if (useEIP155 === true) sig.v  = updateRecoveryParam(sig.v, chainId);\n      return sig;\n    }\n    // Otherwise, try the other `v` value\n    sig.v = 28;\n    pubkey = secp256k1.ecdsaRecover(rs, sig.v - 27, hash, false).slice(1)\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      if (useEIP155 === true) sig.v  = updateRecoveryParam(sig.v, chainId);\n      return sig;\n    } else {\n      // If neither is a match, we should return an error\n      throw new Error('Invalid Ethereum signature returned.');\n    }\n  } catch (err) {\n    throw new Error(err);\n  }\n}\nexports.addRecoveryParam = addRecoveryParam;\n\n// Convert an RLP-serialized transaction (plus signature) into a transaction hash\nexports.hashTransaction = function(serializedTx) {\n  return keccak256(Buffer.from(serializedTx, 'hex')); \n}\n\n// Ensure a param is represented by a buffer\nfunction ensureHexBuffer(x) {\n  if (x === null || x === 0) return Buffer.alloc(0);\n  else if (Buffer.isBuffer(x)) x = x.toString('hex');\n  if (typeof x === 'number') x = `${x.toString(16)}`;\n  else if (typeof x === 'string' && x.slice(0, 2) === '0x') x = x.slice(2);\n  if (x.length % 2 > 0) x = `0${x}`;\n  return Buffer.from(x, 'hex');\n}\n\n// Returns address string given public key buffer\nfunction pubToAddrStr(pub) {\n  return keccak256(pub).slice(-40);\n}\n\nfunction fixLen(msg, length) {\n  const buf = Buffer.alloc(length)\n  if (msg.length < length) {\n    msg.copy(buf, length - msg.length)\n    return buf\n  }\n  return msg.slice(-length)\n}\n\nfunction updateRecoveryParam(v, chainId) {\n  return v + (chainId * 2) + 8;\n}\n\nfunction writeUInt64BE(n, buf, off) {\n  if (typeof n === 'number') n = n.toString(16);\n  const preBuf = Buffer.alloc(8);\n  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;\n  const nBuf = Buffer.from(nStr, 'hex');\n  nBuf.copy(preBuf, preBuf.length - nBuf.length);\n  preBuf.copy(buf, off);\n  return preBuf;\n}\n\nfunction isASCII(str) {\n    return (/^[\\x00-\\x7F]*$/).test(str)\n}\n\nconst chainIds = {\n  mainnet: 1,\n  roptsten: 3,\n  rinkeby: 4,\n  kovan: 42,\n  goerli: 5\n}\n\nconst eip155 = {\n  1: true,\n  3: false,\n  4:false,\n  42: true,\n  5: true\n}\n\n\nexports.chainIds = chainIds;"]},"metadata":{},"sourceType":"script"}