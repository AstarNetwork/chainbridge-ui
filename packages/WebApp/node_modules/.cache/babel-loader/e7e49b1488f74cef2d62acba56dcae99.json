{"ast":null,"code":"const superagent = require('superagent');\n\nconst bitcoin = require('./bitcoin');\n\nconst ethereum = require('./ethereum');\n\nconst {\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  parseLattice1Response,\n  toPaddedDER\n} = require('./util');\n\nconst {\n  ADDR_STR_LEN,\n  ENC_MSG_LEN,\n  decResLengths,\n  deviceCodes,\n  encReqCodes,\n  responseCodes,\n  REQUEST_TYPE_BYTE,\n  VERSION_BYTE,\n  messageConstants,\n  BASE_URL\n} = require('./constants');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst EMPTY_WALLET_UID = Buffer.alloc(32);\n\nclass Client {\n  constructor({\n    baseUrl,\n    crypto,\n    name,\n    privKey,\n    timeout,\n    retryCount\n  } = {}) {\n    // Definitions\n    // if (!baseUrl) throw new Error('baseUrl is required');\n    if (name && name.length > 24) throw new Error('name must be less than 24 characters');\n    if (!crypto) throw new Error('crypto provider is required');\n    this.baseUrl = baseUrl || BASE_URL;\n    this.crypto = crypto;\n    this.name = name || 'Unknown'; // Derive an ECDSA keypair using the p256 curve. The public key will\n    // be used as an identifier\n\n    this.privKey = privKey || this.crypto.randomBytes(32);\n    this.key = getP256KeyPair(this.privKey); //.encode('hex');\n    // Stateful params\n\n    this.ephemeralPub = null;\n    this.sharedSecret = null;\n    this.timeout = timeout || 60000;\n    this.deviceId = null;\n    this.isPaired = false;\n    this.retryCount = retryCount || 3; // Information about the current wallet. Should be null unless we know a wallet is present\n\n    this.activeWallets = {\n      internal: {\n        uid: EMPTY_WALLET_UID,\n        // 32 byte id\n        name: null,\n        // 20 char (max) string\n        capabilities: null,\n        // 4 byte flag\n        external: false\n      },\n      external: {\n        uid: EMPTY_WALLET_UID,\n        // 32 byte id\n        name: null,\n        // 20 char (max) string\n        capabilities: null,\n        // 4 byte flag\n        external: true\n      }\n    };\n  } //=======================================================================\n  // LATTICE FUNCTIONS\n  //=======================================================================\n  // `Connect` will attempt to contact a device based on its deviceId.\n  // The response should include an ephemeral public key, which is used to\n  // pair with the device in a later request\n\n\n  connect(deviceId, cb) {\n    // User may \"re-connect\" if a device ID has previously been stored\n    if (typeof deviceId === 'function') {\n      if (!this.deviceId) return cb('No device ID has been stored. Please connect with your device ID first.');\n      cb = deviceId;\n    } else {\n      // If the user passes in a device ID, connect to that device and save\n      // the new ID for future use.\n      this.deviceId = deviceId;\n    }\n\n    const param = this._buildRequest(deviceCodes.CONNECT, this.pubKeyBytes());\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      this.isPaired = this._handleConnect(res); // Check for an active wallet. This will get bypassed if we are not paired.\n\n      if (this.isPaired) {\n        this._getActiveWallet(err => {\n          return cb(err, this.isPaired);\n        }, true);\n      } else {\n        return cb(null);\n      }\n    });\n  }\n\n  pair(pairingSecret, cb) {\n    // Build the secret hash from the salt\n    const pubKey = this.pubKeyBytes();\n    const nameBuf = Buffer.alloc(25);\n\n    if (this.name.length > 24) {\n      return cb('Name is too many characters. Please change it to <25 characters.');\n    }\n\n    nameBuf.write(this.name); // Make sure we add a null termination byte to the pairing secret\n\n    const preImage = Buffer.concat([pubKey, nameBuf, Buffer.from(pairingSecret)]);\n    const hash = this.crypto.createHash('sha256').update(preImage).digest();\n    const sig = this.key.sign(hash); // returns an array, not a buffer\n\n    const derSig = toPaddedDER(sig);\n    const payload = Buffer.concat([nameBuf, derSig]); // Build the request\n\n    const param = this._buildEncRequest(encReqCodes.FINALIZE_PAIRING, payload);\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err); // Recover the ephemeral key\n\n      const errStr = this._handlePair(res);\n\n      if (errStr) return cb(errStr); // Try to get the active wallet once pairing is successful\n\n      this._getActiveWallet(err => {\n        if (err) return cb(err);\n        return cb(null, this.hasActiveWallet());\n      }, true);\n    });\n  }\n\n  test(data, cb) {\n    if (!data.payload) return cb('First argument must contain `testID` and `payload` fields.');\n    const TEST_DATA_SZ = 500;\n    const payload = Buffer.alloc(TEST_DATA_SZ + 6);\n    payload.writeUInt32BE(data.testID, 0);\n    payload.writeUInt16BE(data.payload.length, 4);\n    data.payload.copy(payload, 6);\n\n    const param = this._buildEncRequest(encReqCodes.TEST, payload);\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n\n      const decrypted = this._handleEncResponse(res, decResLengths.test);\n\n      if (decrypted.err !== null) return cb(decrypted.err);\n      return cb(null, decrypted.data.slice(65)); // remove ephem pub\n    });\n  }\n\n  getAddresses(opts, cb) {\n    const {\n      startPath,\n      n\n    } = opts;\n\n    if (startPath === undefined || n === undefined || startPath.length !== 5) {\n      return cb('Please provide `startPath` and `n` options');\n    }\n\n    const payload = Buffer.alloc(1 + 32 + startPath.length * 4);\n    let off = 0; // WalletUID\n\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off);\n    off += 32; // Build the start path (5x u32 indices)\n\n    for (let i = 0; i < startPath.length; i++) {\n      payload.writeUInt32BE(startPath[i], off);\n      off += 4;\n    } // Specify the number of subsequent addresses to request\n\n\n    payload.writeUInt8(n, off);\n    off++;\n\n    const param = this._buildEncRequest(encReqCodes.GET_ADDRESSES, payload);\n\n    return this._request(param, (err, res) => {\n      if (err) return cb(err);\n\n      const parsedRes = this._handleGetAddresses(res);\n\n      if (parsedRes.err) return cb(parsedRes.err);\n      return cb(null, parsedRes.data);\n    });\n  }\n\n  sign(opts, cb) {\n    const {\n      currency,\n      data\n    } = opts;\n\n    if (currency === undefined || data === undefined) {\n      return cb('Please provide `currency` and `data` options');\n    } else if (signReqResolver[currency] === undefined) {\n      return cb('Unsupported currency');\n    } // Build the signing request payload to send to the device. If we catch\n    // bad params, return an error instead\n\n\n    const req = signReqResolver[currency](data);\n    if (req.err !== undefined) return cb({\n      err: req.err\n    }); // All transaction requests must be put into the same sized buffer\n    // so that checksums may be validated. The full size is 1266 bytes,\n    // but that includes a 1-byte prefix (`SIGN_TRANSACTION`), 2 bytes\n    // indicating the schema type, and 4 bytes for a checksum.\n    // Therefore, the payload itself has 1224 - 7 = 1217 bytes of space.\n\n    const MAX_SIGN_REQ_DATA_SIZE = 1152;\n    if (req.payload.length > MAX_SIGN_REQ_DATA_SIZE) return cb('Transaction is too large'); // Build the payload\n\n    const payload = Buffer.alloc(2 + MAX_SIGN_REQ_DATA_SIZE);\n    let off = 0; // Copy request schema (e.g. ETH or BTC transfer)\n\n    payload.writeUInt16BE(req.schema, off);\n    off += 2; // Copy the wallet UID\n\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off);\n    off += wallet.uid.length; // Build data based on the type of request\n    // Copy the payload of the request\n\n    req.payload.copy(payload, off); // Construct the encrypted request and send it\n\n    const param = this._buildEncRequest(encReqCodes.SIGN_TRANSACTION, payload);\n\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet(err => {\n          if (err) return cb(err);else return this.sign(opts, cb);\n        });\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const parsedRes = this._handleSign(res, currency, req);\n\n        return cb(parsedRes.err, parsedRes.data);\n      }\n    });\n  } //=======================================================================\n  // INTERNAL FUNCTIONS\n  // These handle the logic around building requests and consuming\n  // responses. They take into account the Lattice's serialization scheme\n  // among other protocols.\n  //=======================================================================\n  // Get the active wallet in the device. If we already have one recorded,\n  // we don't need to do anything\n  // returns cb(err) -- err is a string\n\n\n  _getActiveWallet(cb, forceRefresh = false) {\n    if (forceRefresh !== true && (this.hasActiveWallet() === true || this.isPaired !== true)) {\n      // If the active wallet already exists, or if we are not paired, skip the request\n      return cb(null);\n    } else {\n      // No active wallet? Get it from the device\n      const payload = Buffer.alloc(0);\n\n      const param = this._buildEncRequest(encReqCodes.GET_WALLETS, payload);\n\n      return this._request(param, (err, res) => {\n        if (err) {\n          this._resetActiveWallets();\n\n          return cb(err);\n        }\n\n        return cb(this._handleGetWallets(res));\n      });\n    }\n  } // Get the shared secret, derived via ECDH from the local private key\n  // and the ephemeral public key\n  // @returns Buffer\n\n\n  _getSharedSecret() {\n    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which\n    // can lead to problems initializing AES if we don't force a 32 byte BE buffer.\n    return Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));\n  } // Get the ephemeral id, which is the first 4 bytes of the shared secret\n  // generated from the local private key and the ephemeral public key from\n  // the device.\n  // @returns Buffer\n\n\n  _getEphemId() {\n    if (this.ephemeralPub === null) return null; // EphemId is the first 4 bytes of the hash of the shared secret\n\n    const secret = this._getSharedSecret();\n\n    const hash = this.crypto.createHash('sha256').update(secret).digest();\n    return hash.slice(0, 4);\n  }\n\n  _buildEncRequest(enc_request_code, payload) {\n    // Get the ephemeral id - all encrypted requests require there to be an\n    // epehemeral public key in order to send\n    const ephemId = parseInt(this._getEphemId().toString('hex'), 16); // Build the payload and checksum\n\n    const payloadPreCs = Buffer.concat([Buffer.from([enc_request_code]), payload]);\n    const cs = checksum(payloadPreCs);\n    const payloadBuf = Buffer.alloc(payloadPreCs.length + 4); // Lattice validates checksums in little endian\n\n    payloadPreCs.copy(payloadBuf, 0);\n    payloadBuf.writeUInt32LE(cs, payloadPreCs.length); // Encrypt this payload\n\n    const secret = this._getSharedSecret();\n\n    const newEncPayload = aes256_encrypt(payloadBuf, secret); // Write to the overall payload. We must use the same length\n    // for every encrypted request and must include a 32-bit ephemId\n    // along with the encrypted data\n\n    const newPayload = Buffer.alloc(ENC_MSG_LEN + 4); // First 4 bytes are the ephemeral id (in little endian)\n\n    newPayload.writeUInt32LE(ephemId, 0); // Next N bytes\n\n    newEncPayload.copy(newPayload, 4);\n    return this._buildRequest(deviceCodes.ENCRYPTED_REQUEST, newPayload);\n  } // Build a request to send to the device.\n  // @param [request_code] {uint8}  - 8-bit unsigned integer representing the message request code\n  // @param [id] {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)\n  // @param [payload] {buffer} - serialized payload\n  // @returns {buffer}\n\n\n  _buildRequest(request_code, payload) {\n    // Length of payload;\n    // we add 1 to the payload length to account for the request_code byte\n    let L = payload && Buffer.isBuffer(payload) ? payload.length + 1 : 1;\n\n    if (request_code === deviceCodes.ENCRYPTED_REQUEST) {\n      L = 1 + payload.length;\n    }\n\n    let i = 0;\n    const preReq = Buffer.alloc(L + 8); // Build the header\n\n    i = preReq.writeUInt8(VERSION_BYTE, i);\n    i = preReq.writeUInt8(REQUEST_TYPE_BYTE, i);\n    const id = this.crypto.randomBytes(4);\n    i = preReq.writeUInt32BE(parseInt(`0x${id.toString('hex')}`), i);\n    i = preReq.writeUInt16BE(L, i); // Build the payload\n\n    i = preReq.writeUInt8(request_code, i);\n    if (L > 1) i = payload.copy(preReq, i); // Add the checksum\n\n    const cs = checksum(preReq);\n    const req = Buffer.alloc(preReq.length + 4); // 4-byte checksum\n\n    i = preReq.copy(req);\n    req.writeUInt32BE(cs, i);\n    return req;\n  }\n\n  _request(data, cb, retryCount = this.retryCount) {\n    if (!this.deviceId) return cb('Serial is not set. Please set it and try again.');\n    const url = `${this.baseUrl}/${this.deviceId}`;\n    superagent.post(url).timeout(this.timeout).send({\n      data\n    }).then(res => {\n      if (!res || !res.body) return cb(`Invalid response: ${res}`);else if (res.body.status !== 200) return cb(`Error code ${res.body.status}: ${res.body.message}`);\n      const parsed = parseLattice1Response(res.body.message); // If the device is busy, retry if we can\n\n      if ((parsed.responseCode === responseCodes.RESP_ERR_DEV_BUSY || parsed.responseCode === responseCodes.RESP_ERR_GCE_TIMEOUT) && retryCount > 0) {\n        return setTimeout(() => {\n          this._request(data, cb, retryCount - 1);\n        }, 3000);\n      } // If we caugh a `ErrWalletNotPresent` make sure we aren't caching an old ative walletUID\n\n\n      if (parsed.responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) this._resetActiveWallets(); // If there was an error in the response, return it\n\n      if (parsed.err) return cb(parsed.err);\n      return cb(null, parsed.data, parsed.responseCode);\n    }).catch(err => {\n      const isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';\n      if (isTimeout) return cb('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.');else return cb('Failed to make request to device.');\n    });\n  } // ----- Device response handlers -----\n  // Connect will call `StartPairingMode` on the device, which gives the\n  // user 60 seconds to finalize the pairing\n  // This will return an ephemeral public key, which is needed for the next\n  // request. If the device is already paired, this ephemPub is simply used\n  // to encrypt the next request. If the device is not paired, it is needed\n  // to pair the device within 60 seconds.\n  // @returns true if we are paired to the device already\n\n\n  _handleConnect(res) {\n    let off = 0;\n    const pairingStatus = res.readUInt8(off);\n    off++; // If we are already paired, we get the next ephemeral key\n\n    const pub = res.slice(off, res.length).toString('hex');\n    this.ephemeralPub = getP256KeyPairFromPub(pub); // return the state of our pairing\n\n    return pairingStatus === messageConstants.PAIRED;\n  } // All encrypted responses must be decrypted with the previous shared secret. Per specification,\n  // decrypted responses will all contain a 65-byte public key as the prefix, which becomes the \n  // new ephemeralPub.\n\n\n  _handleEncResponse(encRes, len) {\n    // Decrypt response\n    const secret = this._getSharedSecret();\n\n    const encData = encRes.slice(0, ENC_MSG_LEN);\n    const res = aes256_decrypt(encData, secret); // len does not include a 65-byte pubkey that prefies each encResponse\n\n    len += 65; // Validate checksum. It will be the last 4 bytes of the decrypted payload.\n    // The length of the decrypted payload will be fixed for each given message type.\n\n    const toCheck = res.slice(0, len);\n    const cs = parseInt(`0x${res.slice(len, len + 4).toString('hex')}`);\n    const csCheck = checksum(toCheck);\n    if (cs !== csCheck) return {\n      err: `Checksum mismatch in response from Lattice (calculated ${csCheck}, wanted ${cs})`\n    }; // First 65 bytes is the next ephemeral pubkey\n\n    const pub = res.slice(0, 65).toString('hex');\n\n    try {\n      this.ephemeralPub = getP256KeyPairFromPub(pub);\n      return {\n        err: null,\n        data: res\n      };\n    } catch (e) {\n      return {\n        err: `Error handling getAddresses response: ${e.toString()}`\n      };\n    }\n  } // Pair will create a new pairing if the user successfully enters the secret\n  // into the device in time. If successful (status=0), the device will return\n  // a new ephemeral public key, which is used to derive a shared secret\n  // for the next request\n  // @returns error (or null)\n\n\n  _handlePair(encRes) {\n    const d = this._handleEncResponse(encRes, decResLengths.finalizePair);\n\n    if (d.err) return d.err; // Remove the pairing salt - we're paired!\n\n    this.pairingSalt = null;\n    this.isPaired = true;\n    return null;\n  } // GetAddresses will return an array of address strings\n\n\n  _handleGetAddresses(encRes) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getAddresses);\n\n    if (decrypted.err !== null) return decrypted;\n    const addrData = decrypted.data;\n    let off = 65; // Skip 65 byte pubkey prefix\n    // Look for addresses until we reach the end (a 4 byte checksum)\n\n    const addrs = [];\n\n    while (off + 4 < decResLengths.getAddresses) {\n      const addrBytes = addrData.slice(off, off + ADDR_STR_LEN);\n      off += ADDR_STR_LEN; // Return the UTF-8 representation\n\n      const len = addrBytes.indexOf(0); // First 0 is the null terminator\n\n      if (len > 0) addrs.push(addrBytes.slice(0, len).toString());\n    }\n\n    return {\n      data: addrs,\n      err: null\n    };\n  }\n\n  _handleGetWallets(encRes) {\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getWallets);\n\n    if (decrypted.err !== null) return decrypted;\n    const res = decrypted.data;\n    let walletUID; // Read the external wallet data first. If it is non-null, the external wallet will\n    // be the active wallet of the device and we should save it.\n    // If the external wallet is blank, it means there is no card present and we should \n    // save and use the interal wallet.\n    // If both wallets are empty, it means the device still needs to be set up.\n\n    const walletDescriptorLen = 71; // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name\n\n    let off = 65; // Internal first\n\n    let hasActiveWallet = false;\n    walletUID = res.slice(off, off + 32);\n    this.activeWallets.internal.uid = walletUID;\n    this.activeWallets.internal.capabilities = res.readUInt32BE(off + 32);\n    this.activeWallets.internal.name = res.slice(off + 36, off + walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID)) hasActiveWallet = true; // Offset the first item\n\n    off += walletDescriptorLen; // External\n\n    walletUID = res.slice(off, off + 32);\n    this.activeWallets.external.uid = walletUID;\n    this.activeWallets.external.capabilities = res.readUInt32BE(off + 32);\n    this.activeWallets.external.name = res.slice(off + 36, off + walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID)) hasActiveWallet = true;\n    if (hasActiveWallet === true) return null;else return 'No active wallet.';\n  }\n\n  _handleSign(encRes, currencyType, req = null) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.sign);\n\n    if (decrypted.err !== null) return {\n      err: decrypted.err\n    };\n    const PUBKEY_PREFIX_LEN = 65;\n    const PKH_PREFIX_LEN = 20;\n    let off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix\n\n    const res = decrypted.data; // Get the change data if we are making a BTC transaction\n\n    let changeRecipient;\n\n    if (currencyType === 'BTC') {\n      const changeVersion = bitcoin.addressVersion[req.changeData.changeVersion];\n      const changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN);\n      off += PKH_PREFIX_LEN;\n      changeRecipient = bitcoin.getBitcoinAddress(changePubkeyhash, changeVersion);\n    } // Start building return data\n\n\n    const returnData = {\n      err: null,\n      data: null\n    };\n    const DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long\n\n    const SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots\n\n    const PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;\n\n    if (currencyType === 'BTC') {\n      const compressedPubLength = 33; // Size of compressed public key\n\n      const pubkeys = [];\n      const sigs = [];\n      let n = 0; // Parse the signature for each output -- they are returned\n      // in the serialized payload in form [pubkey, sig]\n      // There is one signature per output\n\n      while (off < res.length) {\n        // Exit out if we have seen all the returned sigs and pubkeys\n        if (res[off] !== 0x30) break; // Otherwise grab another set\n        // Note that all DER sigs returned fill the maximum 74 byte buffer, but also\n        // contain a length at off+1, which we use to parse the non-zero data.\n        // First get the signature from its slot\n\n        const sigStart = off;\n        const sigEnd = off + 2 + res[off + 1];\n        sigs.push(res.slice(sigStart, sigEnd)); // Next, shift by the full set of signatures to hit the respective pubkey\n        // NOTE: The data returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]\n\n        const pubStart = n * compressedPubLength + PUBKEYS_OFFSET;\n        const pubEnd = (n + 1) * compressedPubLength + PUBKEYS_OFFSET;\n        pubkeys.push(res.slice(pubStart, pubEnd)); // Update offset to hit the next signature slot\n\n        off += DERLength;\n        n += 1;\n      } // Build the transaction data to be serialized\n\n\n      const preSerializedData = {\n        inputs: [],\n        outputs: [],\n        isSegwitSpend: req.origData.isSegwit,\n        network: req.origData.network,\n        crypto: this.crypto\n      }; // First output comes from request dta\n\n      preSerializedData.outputs.push({\n        value: req.origData.value,\n        recipient: req.origData.recipient\n      });\n\n      if (req.changeData.value > 0) {\n        // Second output comes from change data\n        preSerializedData.outputs.push({\n          value: req.changeData.value,\n          recipient: changeRecipient\n        });\n      } // Add the inputs\n\n\n      for (let i = 0; i < sigs.length; i++) {\n        preSerializedData.inputs.push({\n          hash: req.origData.prevOuts[i].txHash,\n          index: req.origData.prevOuts[i].index,\n          sig: sigs[i],\n          pubkey: pubkeys[i]\n        });\n      } // Finally, serialize the transaction\n\n\n      const serializedTx = bitcoin.serializeTx(preSerializedData); // Generate the transaction hash so the user can look this transaction up later\n\n      let preImageTxHash = serializedTx;\n\n      if (preSerializedData.isSegwitSpend === true) {\n        // Segwit transactions need to be re-serialized using legacy serialization\n        // before the transaction hash is calculated. This allows legacy clients\n        // to validate the transactions.\n        preSerializedData.isSegwitSpend = false;\n        preImageTxHash = bitcoin.serializeTx(preSerializedData);\n      }\n\n      let txHash = this.crypto.createHash('sha256').update(Buffer.from(preImageTxHash, 'hex')).digest();\n      txHash = this.crypto.createHash('sha256').update(txHash).digest().reverse().toString('hex'); // Add extra data for debugging/lookup purposes\n\n      returnData.data = {\n        tx: serializedTx,\n        txHash,\n        changeRecipient,\n        sigs\n      };\n    } else if (currencyType === 'ETH') {\n      const sig = parseDER(res.slice(off, off + 2 + res[off + 1]));\n      off += DERLength;\n      const ethAddr = res.slice(off, off + 20); // Determine the `v` param and add it to the sig before returning\n\n      const rawTx = ethereum.buildEthRawTx(req, sig, ethAddr, req.useEIP155);\n      returnData.data = {\n        tx: `0x${rawTx}`,\n        txHash: `0x${ethereum.hashTransaction(rawTx)}`,\n        sig: {\n          v: sig.v,\n          r: sig.r.toString('hex'),\n          s: sig.s.toString('hex')\n        },\n        signer: ethAddr\n      };\n    } else if (currencyType === 'ETH_MSG') {\n      const sig = parseDER(res.slice(off, off + 2 + res[off + 1]));\n      off += DERLength;\n      const signer = res.slice(off, off + 20);\n      const validatedSig = ethereum.validateEthereumMsgResponse({\n        signer,\n        sig\n      }, req);\n      returnData.data = {\n        sig: {\n          v: validatedSig.v,\n          r: validatedSig.r.toString('hex'),\n          s: validatedSig.s.toString('hex')\n        },\n        signer\n      };\n    }\n\n    return returnData;\n  }\n\n  _resetActiveWallets() {\n    this.activeWallets.internal.uid = EMPTY_WALLET_UID;\n    this.activeWallets.internal.name = null;\n    this.activeWallets.internal.capabilities = null;\n    this.activeWallets.external.uid = EMPTY_WALLET_UID;\n    this.activeWallets.external.name = null;\n    this.activeWallets.external.capabilities = null;\n    return;\n  }\n\n  getActiveWallet() {\n    if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {\n      return this.activeWallets.external;\n    } else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {\n      return this.activeWallets.internal;\n    } else {\n      return null;\n    }\n  }\n\n  hasActiveWallet() {\n    return this.getActiveWallet() !== null;\n  } // Get 64 bytes representing the public key\n  // This is the uncompressed key without the leading 04 byte\n\n\n  pubKeyBytes(LE = false) {\n    const k = this.key.getPublic();\n    const p = k.encode('hex');\n    const pb = Buffer.from(p, 'hex');\n\n    if (LE === true) {\n      // Need to flip X and Y components to little endian\n      const x = pb.slice(1, 33).reverse();\n      const y = pb.slice(33, 65).reverse();\n      return Buffer.concat([pb[0], x, y]);\n    } else {\n      return pb;\n    }\n  }\n\n}\n\nmodule.exports = Client;","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/gridplus-sdk/src/client.js"],"names":["superagent","require","bitcoin","ethereum","signReqResolver","aes256_decrypt","aes256_encrypt","parseDER","checksum","getP256KeyPair","getP256KeyPairFromPub","parseLattice1Response","toPaddedDER","ADDR_STR_LEN","ENC_MSG_LEN","decResLengths","deviceCodes","encReqCodes","responseCodes","REQUEST_TYPE_BYTE","VERSION_BYTE","messageConstants","BASE_URL","Buffer","EMPTY_WALLET_UID","alloc","Client","constructor","baseUrl","crypto","name","privKey","timeout","retryCount","length","Error","randomBytes","key","ephemeralPub","sharedSecret","deviceId","isPaired","activeWallets","internal","uid","capabilities","external","connect","cb","param","_buildRequest","CONNECT","pubKeyBytes","_request","err","res","_handleConnect","_getActiveWallet","pair","pairingSecret","pubKey","nameBuf","write","preImage","concat","from","hash","createHash","update","digest","sig","sign","derSig","payload","_buildEncRequest","FINALIZE_PAIRING","errStr","_handlePair","hasActiveWallet","test","data","TEST_DATA_SZ","writeUInt32BE","testID","writeUInt16BE","copy","TEST","decrypted","_handleEncResponse","slice","getAddresses","opts","startPath","n","undefined","off","wallet","getActiveWallet","i","writeUInt8","GET_ADDRESSES","parsedRes","_handleGetAddresses","currency","req","MAX_SIGN_REQ_DATA_SIZE","schema","SIGN_TRANSACTION","responseCode","RESP_ERR_WALLET_NOT_PRESENT","_handleSign","forceRefresh","GET_WALLETS","_resetActiveWallets","_handleGetWallets","_getSharedSecret","derive","getPublic","toArray","_getEphemId","secret","enc_request_code","ephemId","parseInt","toString","payloadPreCs","cs","payloadBuf","writeUInt32LE","newEncPayload","newPayload","ENCRYPTED_REQUEST","request_code","L","isBuffer","preReq","id","url","post","send","then","body","status","message","parsed","RESP_ERR_DEV_BUSY","RESP_ERR_GCE_TIMEOUT","setTimeout","catch","isTimeout","code","errno","pairingStatus","readUInt8","pub","PAIRED","encRes","len","encData","toCheck","csCheck","e","d","finalizePair","pairingSalt","addrData","addrs","addrBytes","indexOf","push","getWallets","walletUID","walletDescriptorLen","readUInt32BE","equals","currencyType","PUBKEY_PREFIX_LEN","PKH_PREFIX_LEN","changeRecipient","changeVersion","addressVersion","changeData","changePubkeyhash","getBitcoinAddress","returnData","DERLength","SIGS_OFFSET","PUBKEYS_OFFSET","compressedPubLength","pubkeys","sigs","sigStart","sigEnd","pubStart","pubEnd","preSerializedData","inputs","outputs","isSegwitSpend","origData","isSegwit","network","value","recipient","prevOuts","txHash","index","pubkey","serializedTx","serializeTx","preImageTxHash","reverse","tx","ethAddr","rawTx","buildEthRawTx","useEIP155","hashTransaction","v","r","s","signer","validatedSig","validateEthereumMsgResponse","LE","k","p","encode","pb","x","y","module","exports"],"mappings":"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","sourcesContent":["const superagent = require('superagent');\nconst bitcoin = require('./bitcoin');\nconst ethereum = require('./ethereum');\nconst {\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  parseLattice1Response,\n  toPaddedDER,\n} = require('./util');\nconst {\n  ADDR_STR_LEN,\n  ENC_MSG_LEN,\n  decResLengths,\n  deviceCodes,\n  encReqCodes,\n  responseCodes,\n  REQUEST_TYPE_BYTE,\n  VERSION_BYTE,\n  messageConstants,\n  BASE_URL,\n} = require('./constants');\nconst Buffer = require('buffer/').Buffer;\nconst EMPTY_WALLET_UID = Buffer.alloc(32);\n\nclass Client {\n  constructor({ baseUrl, crypto, name, privKey, timeout, retryCount } = {}) {\n    // Definitions\n    // if (!baseUrl) throw new Error('baseUrl is required');\n    if (name && name.length > 24) throw new Error('name must be less than 24 characters');\n    if (!crypto) throw new Error('crypto provider is required');\n    this.baseUrl = baseUrl || BASE_URL;\n    this.crypto = crypto;\n    this.name = name || 'Unknown';\n    \n    // Derive an ECDSA keypair using the p256 curve. The public key will\n    // be used as an identifier\n    this.privKey = privKey || this.crypto.randomBytes(32);\n    this.key = getP256KeyPair(this.privKey);//.encode('hex');\n\n    // Stateful params\n    this.ephemeralPub = null;\n    this.sharedSecret = null;\n    this.timeout = timeout || 60000;\n    this.deviceId = null;\n    this.isPaired = false;\n    this.retryCount = retryCount || 3;\n\n    // Information about the current wallet. Should be null unless we know a wallet is present\n    this.activeWallets = {\n      internal: {\n        uid: EMPTY_WALLET_UID,           // 32 byte id\n        name: null,                      // 20 char (max) string\n        capabilities: null,              // 4 byte flag\n        external: false,\n      },\n      external: {\n        uid: EMPTY_WALLET_UID,           // 32 byte id\n        name: null,                      // 20 char (max) string\n        capabilities: null,              // 4 byte flag\n        external: true,\n      }\n    }\n  }\n  \n  //=======================================================================\n  // LATTICE FUNCTIONS\n  //=======================================================================\n\n  // `Connect` will attempt to contact a device based on its deviceId.\n  // The response should include an ephemeral public key, which is used to\n  // pair with the device in a later request\n  connect(deviceId, cb) {\n    // User may \"re-connect\" if a device ID has previously been stored\n    if (typeof deviceId === 'function') {\n      if (!this.deviceId) \n        return cb('No device ID has been stored. Please connect with your device ID first.')\n      cb = deviceId;\n    } else {\n      // If the user passes in a device ID, connect to that device and save\n      // the new ID for future use.\n      this.deviceId = deviceId;\n    }\n    const param = this._buildRequest(deviceCodes.CONNECT, this.pubKeyBytes());\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      this.isPaired = this._handleConnect(res);\n      // Check for an active wallet. This will get bypassed if we are not paired.\n      if (this.isPaired) {\n        this._getActiveWallet((err) => {\n          return cb(err, this.isPaired);\n        }, true);\n      } else {\n        return cb(null);\n      }\n      \n    });\n  }\n\n  pair(pairingSecret, cb) {\n    // Build the secret hash from the salt\n    const pubKey = this.pubKeyBytes();\n    const nameBuf = Buffer.alloc(25);\n    if (this.name.length > 24) {\n      return cb('Name is too many characters. Please change it to <25 characters.');\n    }\n    nameBuf.write(this.name);\n    // Make sure we add a null termination byte to the pairing secret\n    const preImage = Buffer.concat([pubKey, nameBuf, Buffer.from(pairingSecret)]);\n    const hash = this.crypto.createHash('sha256').update(preImage).digest();\n    const sig = this.key.sign(hash); // returns an array, not a buffer\n    const derSig = toPaddedDER(sig);\n    const payload = Buffer.concat([nameBuf, derSig]);\n\n    // Build the request\n    const param = this._buildEncRequest(encReqCodes.FINALIZE_PAIRING, payload);\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      // Recover the ephemeral key\n      const errStr = this._handlePair(res);\n      if (errStr) return cb(errStr);\n      // Try to get the active wallet once pairing is successful\n      this._getActiveWallet((err) => {\n        if (err) return cb(err);\n        return cb(null, this.hasActiveWallet());\n      }, true);\n    })  \n  }\n\n  test(data, cb) {\n    if (!data.payload)\n      return cb('First argument must contain `testID` and `payload` fields.');\n    const TEST_DATA_SZ = 500;\n    const payload = Buffer.alloc(TEST_DATA_SZ + 6);\n    payload.writeUInt32BE(data.testID, 0);\n    payload.writeUInt16BE(data.payload.length, 4);\n    data.payload.copy(payload, 6);\n    const param = this._buildEncRequest(encReqCodes.TEST, payload);\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      const decrypted = this._handleEncResponse(res, decResLengths.test);\n      if (decrypted.err !== null ) \n        return cb(decrypted.err);\n      return cb(null, decrypted.data.slice(65)); // remove ephem pub\n    })\n  }\n\n  getAddresses(opts, cb) {\n    const { startPath, n } = opts;\n    if (startPath === undefined || n === undefined || startPath.length !== 5) {\n      return cb('Please provide `startPath` and `n` options');\n    }\n\n    const payload = Buffer.alloc(1 + 32 + startPath.length * 4);\n    let off = 0;\n\n    // WalletUID\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off); off += 32;\n    // Build the start path (5x u32 indices)\n    for (let i = 0; i < startPath.length; i++) {\n      payload.writeUInt32BE(startPath[i], off);\n      off += 4;\n    }\n    // Specify the number of subsequent addresses to request\n    payload.writeUInt8(n, off); off++;\n    const param = this._buildEncRequest(encReqCodes.GET_ADDRESSES, payload);\n    return this._request(param, (err, res) => {\n      if (err) return cb(err);\n      const parsedRes = this._handleGetAddresses(res);\n      if (parsedRes.err) return cb(parsedRes.err);\n      return cb(null, parsedRes.data);\n    })\n  }\n\n  sign(opts, cb) {\n    const { currency, data } = opts;\n    if (currency === undefined || data === undefined) {\n      return cb('Please provide `currency` and `data` options');\n    } else if (signReqResolver[currency] === undefined) {\n      return cb('Unsupported currency');\n    }\n\n    // Build the signing request payload to send to the device. If we catch\n    // bad params, return an error instead\n    const req = signReqResolver[currency](data);\n    if (req.err !== undefined) return cb({ err: req.err });\n    // All transaction requests must be put into the same sized buffer\n    // so that checksums may be validated. The full size is 1266 bytes,\n    // but that includes a 1-byte prefix (`SIGN_TRANSACTION`), 2 bytes\n    // indicating the schema type, and 4 bytes for a checksum.\n    // Therefore, the payload itself has 1224 - 7 = 1217 bytes of space.\n    const MAX_SIGN_REQ_DATA_SIZE = 1152;\n    if (req.payload.length > MAX_SIGN_REQ_DATA_SIZE)\n      return cb('Transaction is too large');\n\n    // Build the payload\n    const payload = Buffer.alloc(2 + MAX_SIGN_REQ_DATA_SIZE);\n    let off = 0;\n    // Copy request schema (e.g. ETH or BTC transfer)\n    payload.writeUInt16BE(req.schema, off); off += 2;\n\n    // Copy the wallet UID\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off); off += wallet.uid.length;\n    // Build data based on the type of request\n    // Copy the payload of the request\n    req.payload.copy(payload, off);\n    // Construct the encrypted request and send it\n    const param = this._buildEncRequest(encReqCodes.SIGN_TRANSACTION, payload);\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet((err) => {\n          if (err) return cb(err)\n          else     return this.sign(opts, cb);\n        })\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const parsedRes = this._handleSign(res, currency, req);\n        return cb(parsedRes.err, parsedRes.data);\n      }\n    })\n  }\n\n  //=======================================================================\n  // INTERNAL FUNCTIONS\n  // These handle the logic around building requests and consuming\n  // responses. They take into account the Lattice's serialization scheme\n  // among other protocols.\n  //=======================================================================\n\n  // Get the active wallet in the device. If we already have one recorded,\n  // we don't need to do anything\n  // returns cb(err) -- err is a string\n  _getActiveWallet(cb, forceRefresh=false) {\n    if (forceRefresh !== true && (this.hasActiveWallet() === true || this.isPaired !== true)) {\n      // If the active wallet already exists, or if we are not paired, skip the request\n      return cb(null);\n    } else {\n      // No active wallet? Get it from the device\n      const payload = Buffer.alloc(0);\n      const param = this._buildEncRequest(encReqCodes.GET_WALLETS, payload);\n      return this._request(param, (err, res) => {\n        if (err) {\n          this._resetActiveWallets();\n          return cb(err);\n        }\n        return cb(this._handleGetWallets(res));\n      })\n    }\n  }\n\n  // Get the shared secret, derived via ECDH from the local private key\n  // and the ephemeral public key\n  // @returns Buffer\n  _getSharedSecret() {\n    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which\n    // can lead to problems initializing AES if we don't force a 32 byte BE buffer.\n    return Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));\n  }\n\n  // Get the ephemeral id, which is the first 4 bytes of the shared secret\n  // generated from the local private key and the ephemeral public key from\n  // the device.\n  // @returns Buffer\n  _getEphemId() {\n    if (this.ephemeralPub === null) return null;\n    // EphemId is the first 4 bytes of the hash of the shared secret\n    const secret = this._getSharedSecret();\n    const hash = this.crypto.createHash('sha256').update(secret).digest();\n    return hash.slice(0, 4);\n  }\n\n  _buildEncRequest(enc_request_code, payload) {\n    // Get the ephemeral id - all encrypted requests require there to be an\n    // epehemeral public key in order to send\n    const ephemId = parseInt(this._getEphemId().toString('hex'), 16)\n    \n    // Build the payload and checksum\n    const payloadPreCs = Buffer.concat([Buffer.from([enc_request_code]), payload]);\n    const cs = checksum(payloadPreCs);\n    const payloadBuf = Buffer.alloc(payloadPreCs.length + 4);\n\n    // Lattice validates checksums in little endian\n    payloadPreCs.copy(payloadBuf, 0);\n    payloadBuf.writeUInt32LE(cs, payloadPreCs.length);\n    // Encrypt this payload\n    const secret = this._getSharedSecret();\n    const newEncPayload = aes256_encrypt(payloadBuf, secret);\n\n    // Write to the overall payload. We must use the same length\n    // for every encrypted request and must include a 32-bit ephemId\n    // along with the encrypted data\n    const newPayload = Buffer.alloc(ENC_MSG_LEN + 4);\n    // First 4 bytes are the ephemeral id (in little endian)\n    newPayload.writeUInt32LE(ephemId, 0);\n    // Next N bytes\n    newEncPayload.copy(newPayload, 4);\n    return this._buildRequest(deviceCodes.ENCRYPTED_REQUEST, newPayload);\n  \n  }\n\n  // Build a request to send to the device.\n  // @param [request_code] {uint8}  - 8-bit unsigned integer representing the message request code\n  // @param [id] {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)\n  // @param [payload] {buffer} - serialized payload\n  // @returns {buffer}\n  _buildRequest(request_code, payload) {\n    // Length of payload;\n    // we add 1 to the payload length to account for the request_code byte\n    let L = payload && Buffer.isBuffer(payload) ? payload.length + 1 : 1;\n    if (request_code === deviceCodes.ENCRYPTED_REQUEST) {\n      L = 1 + payload.length;\n    }\n    let i = 0;\n    const preReq = Buffer.alloc(L + 8);\n    // Build the header\n    i = preReq.writeUInt8(VERSION_BYTE, i);\n    i = preReq.writeUInt8(REQUEST_TYPE_BYTE, i);\n    const id = this.crypto.randomBytes(4);\n    i = preReq.writeUInt32BE(parseInt(`0x${id.toString('hex')}`), i);\n    i = preReq.writeUInt16BE(L, i);\n    // Build the payload\n    i = preReq.writeUInt8(request_code, i);\n    if (L > 1) i = payload.copy(preReq, i);\n    // Add the checksum\n    const cs = checksum(preReq);\n    const req = Buffer.alloc(preReq.length + 4); // 4-byte checksum\n    i = preReq.copy(req);\n    req.writeUInt32BE(cs, i);\n    return req;\n  }\n\n  _request(data, cb, retryCount=this.retryCount) {\n    if (!this.deviceId) return cb('Serial is not set. Please set it and try again.');\n    const url = `${this.baseUrl}/${this.deviceId}`;\n    superagent.post(url).timeout(this.timeout)\n    .send({data})\n    .then(res => {\n      if (!res || !res.body) return cb(`Invalid response: ${res}`)\n      else if (res.body.status !== 200) return cb(`Error code ${res.body.status}: ${res.body.message}`)\n      const parsed = parseLattice1Response(res.body.message);\n      // If the device is busy, retry if we can\n      if (( parsed.responseCode === responseCodes.RESP_ERR_DEV_BUSY ||\n            parsed.responseCode === responseCodes.RESP_ERR_GCE_TIMEOUT ) \n            && (retryCount > 0)) {\n        return setTimeout(() => { this._request(data, cb, retryCount-1) }, 3000);\n      }\n      // If we caugh a `ErrWalletNotPresent` make sure we aren't caching an old ative walletUID\n      if (parsed.responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) \n        this._resetActiveWallets();\n      // If there was an error in the response, return it\n      if (parsed.err) \n        return cb(parsed.err);\n      return cb(null, parsed.data, parsed.responseCode); \n    })\n    .catch((err) => {\n      const isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';\n      if (isTimeout)\n        return cb('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.')\n      else\n        return cb('Failed to make request to device.');\n    });\n  }\n\n  // ----- Device response handlers -----\n\n  // Connect will call `StartPairingMode` on the device, which gives the\n  // user 60 seconds to finalize the pairing\n  // This will return an ephemeral public key, which is needed for the next\n  // request. If the device is already paired, this ephemPub is simply used\n  // to encrypt the next request. If the device is not paired, it is needed\n  // to pair the device within 60 seconds.\n  // @returns true if we are paired to the device already\n  _handleConnect(res) {\n    let off = 0;\n    const pairingStatus = res.readUInt8(off); off++;\n    // If we are already paired, we get the next ephemeral key\n    const pub = res.slice(off, res.length).toString('hex');\n    this.ephemeralPub = getP256KeyPairFromPub(pub);\n    // return the state of our pairing\n    return (pairingStatus === messageConstants.PAIRED);\n  }\n\n  // All encrypted responses must be decrypted with the previous shared secret. Per specification,\n  // decrypted responses will all contain a 65-byte public key as the prefix, which becomes the \n  // new ephemeralPub.\n  _handleEncResponse(encRes, len) {\n    // Decrypt response\n    const secret = this._getSharedSecret();\n    const encData = encRes.slice(0, ENC_MSG_LEN);\n    const res = aes256_decrypt(encData, secret);\n    // len does not include a 65-byte pubkey that prefies each encResponse\n    len += 65;\n    // Validate checksum. It will be the last 4 bytes of the decrypted payload.\n    // The length of the decrypted payload will be fixed for each given message type.\n    const toCheck = res.slice(0, len);\n    const cs = parseInt(`0x${res.slice(len, len+4).toString('hex')}`);\n    const csCheck = checksum(toCheck);\n    if (cs !== csCheck) return { err: `Checksum mismatch in response from Lattice (calculated ${csCheck}, wanted ${cs})` };\n\n    // First 65 bytes is the next ephemeral pubkey\n    const pub = res.slice(0, 65).toString('hex');\n    try {\n      this.ephemeralPub = getP256KeyPairFromPub(pub);\n      return { err: null, data: res };\n    } catch (e) {\n      return { err: `Error handling getAddresses response: ${e.toString()}` };\n    }\n  }\n\n  // Pair will create a new pairing if the user successfully enters the secret\n  // into the device in time. If successful (status=0), the device will return\n  // a new ephemeral public key, which is used to derive a shared secret\n  // for the next request\n  // @returns error (or null)\n  _handlePair(encRes) {\n    const d = this._handleEncResponse(encRes, decResLengths.finalizePair);\n    if (d.err) return d.err;\n    // Remove the pairing salt - we're paired!\n    this.pairingSalt = null;\n    this.isPaired = true;\n    return null;\n  }\n\n  // GetAddresses will return an array of address strings\n  _handleGetAddresses(encRes) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getAddresses);\n    if (decrypted.err !== null ) return decrypted;\n\n    const addrData = decrypted.data;\n    let off = 65; // Skip 65 byte pubkey prefix\n    // Look for addresses until we reach the end (a 4 byte checksum)\n    const addrs = [];\n    while (off + 4 < decResLengths.getAddresses) {\n      const addrBytes = addrData.slice(off, off+ADDR_STR_LEN); off += ADDR_STR_LEN;\n      // Return the UTF-8 representation\n      const len = addrBytes.indexOf(0); // First 0 is the null terminator\n      if (len > 0)\n        addrs.push(addrBytes.slice(0, len).toString());\n    }\n    return { data: addrs, err: null };\n  }\n\n  _handleGetWallets(encRes) {\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getWallets);\n    if (decrypted.err !== null) return decrypted;\n    const res = decrypted.data;\n    let walletUID;\n    // Read the external wallet data first. If it is non-null, the external wallet will\n    // be the active wallet of the device and we should save it.\n    // If the external wallet is blank, it means there is no card present and we should \n    // save and use the interal wallet.\n    // If both wallets are empty, it means the device still needs to be set up.\n    const walletDescriptorLen = 71;\n    // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name\n    let off = 65;\n    // Internal first\n    let hasActiveWallet = false;\n    walletUID = res.slice(off, off+32);\n    this.activeWallets.internal.uid = walletUID;\n    this.activeWallets.internal.capabilities = res.readUInt32BE(off+32);\n    this.activeWallets.internal.name = res.slice(off+36, off+walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID))\n      hasActiveWallet = true;\n\n    // Offset the first item\n    off += walletDescriptorLen;\n    \n    // External\n    walletUID = res.slice(off, off+32);\n    this.activeWallets.external.uid = walletUID;\n    this.activeWallets.external.capabilities = res.readUInt32BE(off+32);\n    this.activeWallets.external.name = res.slice(off+36, off+walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID))\n      hasActiveWallet = true;\n    if (hasActiveWallet === true)\n      return null;\n    else\n      return 'No active wallet.';\n  }\n\n  _handleSign(encRes, currencyType, req=null) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.sign);\n    if (decrypted.err !== null ) return { err: decrypted.err };\n    const PUBKEY_PREFIX_LEN = 65;\n    const PKH_PREFIX_LEN = 20;\n    let off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix\n    const res = decrypted.data;\n\n    // Get the change data if we are making a BTC transaction\n    let changeRecipient;\n    if (currencyType === 'BTC') {\n      const changeVersion = bitcoin.addressVersion[req.changeData.changeVersion];\n      const changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN); off += PKH_PREFIX_LEN;\n      changeRecipient = bitcoin.getBitcoinAddress(changePubkeyhash, changeVersion);\n    }\n    // Start building return data\n    const returnData = { err: null, data: null };\n    const DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long\n    const SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots\n    const PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;\n    \n    if (currencyType === 'BTC') {\n      const compressedPubLength = 33;  // Size of compressed public key\n      const pubkeys = [];\n      const sigs = [];\n      let n = 0;\n      // Parse the signature for each output -- they are returned\n      // in the serialized payload in form [pubkey, sig]\n      // There is one signature per output\n      while (off < res.length) {\n        // Exit out if we have seen all the returned sigs and pubkeys\n        if (res[off] !== 0x30) break;\n        // Otherwise grab another set\n        // Note that all DER sigs returned fill the maximum 74 byte buffer, but also\n        // contain a length at off+1, which we use to parse the non-zero data.\n        // First get the signature from its slot\n        const sigStart = off;\n        const sigEnd = off + 2 + res[off + 1];\n        sigs.push(res.slice(sigStart, sigEnd));\n        // Next, shift by the full set of signatures to hit the respective pubkey\n        // NOTE: The data returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]\n        const pubStart = (n * compressedPubLength) + PUBKEYS_OFFSET;\n        const pubEnd = ((n+1) * compressedPubLength) + PUBKEYS_OFFSET;\n        pubkeys.push(res.slice(pubStart, pubEnd));\n        // Update offset to hit the next signature slot\n        off += DERLength;\n        n += 1;\n      }\n      // Build the transaction data to be serialized\n      const preSerializedData = {\n        inputs: [],\n        outputs: [],\n        isSegwitSpend: req.origData.isSegwit,\n        network: req.origData.network,\n        crypto: this.crypto,\n      };\n\n      // First output comes from request dta\n      preSerializedData.outputs.push({\n        value: req.origData.value,\n        recipient: req.origData.recipient,\n      });\n      if (req.changeData.value > 0) {\n        // Second output comes from change data\n        preSerializedData.outputs.push({\n          value: req.changeData.value,\n          recipient: changeRecipient,\n        });\n      }\n      \n      // Add the inputs\n      for (let i = 0; i < sigs.length; i++) {\n        preSerializedData.inputs.push({\n          hash: req.origData.prevOuts[i].txHash,\n          index: req.origData.prevOuts[i].index,\n          sig: sigs[i],\n          pubkey: pubkeys[i],\n        });\n      }\n\n      // Finally, serialize the transaction\n      const serializedTx = bitcoin.serializeTx(preSerializedData);\n      // Generate the transaction hash so the user can look this transaction up later\n      let preImageTxHash = serializedTx;\n      if (preSerializedData.isSegwitSpend === true) {\n        // Segwit transactions need to be re-serialized using legacy serialization\n        // before the transaction hash is calculated. This allows legacy clients\n        // to validate the transactions.\n        preSerializedData.isSegwitSpend = false;\n        preImageTxHash = bitcoin.serializeTx(preSerializedData);\n      }  \n      let txHash = this.crypto.createHash('sha256').update(Buffer.from(preImageTxHash, 'hex')).digest();\n      txHash = this.crypto.createHash('sha256').update(txHash).digest().reverse().toString('hex');\n      \n      // Add extra data for debugging/lookup purposes\n      returnData.data = {\n        tx: serializedTx,\n        txHash,\n        changeRecipient,\n        sigs,\n      }\n    } else if (currencyType === 'ETH') {\n      const sig = parseDER(res.slice(off, (off + 2 + res[off + 1]))); off += DERLength;\n      const ethAddr = res.slice(off, off + 20);\n      // Determine the `v` param and add it to the sig before returning\n      const rawTx = ethereum.buildEthRawTx(req, sig, ethAddr, req.useEIP155);\n      returnData.data = {\n        tx: `0x${rawTx}`,\n        txHash: `0x${ethereum.hashTransaction(rawTx)}`,\n        sig: {\n          v: sig.v,\n          r: sig.r.toString('hex'),\n          s: sig.s.toString('hex'),\n        },\n        signer: ethAddr,\n      };\n    } else if (currencyType === 'ETH_MSG') {\n      const sig = parseDER(res.slice(off, (off + 2 + res[off + 1]))); off += DERLength;\n      const signer = res.slice(off, off + 20);\n      const validatedSig = ethereum.validateEthereumMsgResponse({ signer, sig }, req);\n      returnData.data = {\n        sig: {\n          v: validatedSig.v,\n          r: validatedSig.r.toString('hex'),\n          s: validatedSig.s.toString('hex'),\n        },\n        signer,\n      }\n    }\n\n    return returnData;\n  }\n\n  _resetActiveWallets() {\n    this.activeWallets.internal.uid = EMPTY_WALLET_UID;\n    this.activeWallets.internal.name = null;\n    this.activeWallets.internal.capabilities = null;\n    this.activeWallets.external.uid = EMPTY_WALLET_UID;\n    this.activeWallets.external.name = null;\n    this.activeWallets.external.capabilities = null;\n    return;\n  }\n\n  getActiveWallet() {\n    if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {\n      return this.activeWallets.external;\n    } else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {\n      return this.activeWallets.internal;\n    } else {\n      return null;\n    }\n  }\n\n  hasActiveWallet() {\n    return this.getActiveWallet() !== null;\n  }\n  \n  // Get 64 bytes representing the public key\n  // This is the uncompressed key without the leading 04 byte\n  pubKeyBytes(LE=false) {\n    const k = this.key.getPublic();\n    const p = k.encode('hex');\n    const pb = Buffer.from(p, 'hex');\n    if (LE === true) {\n      // Need to flip X and Y components to little endian\n      const x = pb.slice(1, 33).reverse();\n      const y = pb.slice(33, 65).reverse();\n      return Buffer.concat([pb[0], x, y]);\n    } else {\n      return pb;\n    }\n  }\n\n}\n\nmodule.exports = Client;"]},"metadata":{},"sourceType":"script"}