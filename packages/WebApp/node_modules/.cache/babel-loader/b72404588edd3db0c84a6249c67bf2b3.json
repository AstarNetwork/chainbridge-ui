{"ast":null,"code":"// Static utility functions\nconst {\n  buildBitcoinTxRequest\n} = require('./bitcoin');\n\nconst {\n  buildEthereumTxRequest,\n  buildEthereumMsgRequest\n} = require('./ethereum');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst aes = require('aes-js');\n\nconst crc32 = require('crc-32');\n\nconst elliptic = require('elliptic');\n\nconst {\n  AES_IV,\n  responseCodes,\n  responseMsgs,\n  VERSION_BYTE\n} = require('./constants');\n\nconst EC = elliptic.ec;\nconst ec = new EC('p256'); //--------------------------------------------------\n// LATTICE UTILS\n//--------------------------------------------------\n// Parse a response from the Lattice1\n\nfunction parseLattice1Response(r) {\n  const parsed = {\n    err: null,\n    data: null\n  };\n  const b = Buffer.from(r, 'hex');\n  let off = 0; // Get protocol version\n\n  const protoVer = b.readUInt8(off);\n  off++;\n\n  if (protoVer !== VERSION_BYTE) {\n    parsed.err = 'Incorrect protocol version. Please update your SDK';\n    return parsed;\n  } // Get the type of response\n  // Should always be 0x00\n\n\n  const msgType = b.readUInt8(off);\n  off++;\n\n  if (msgType !== 0x00) {\n    parsed.err = 'Incorrect response from Lattice1';\n    return parsed;\n  } // Get the payload\n\n\n  b.readUInt32BE(off);\n  off += 4; // First 4 bytes is the id, but we don't need that anymore\n\n  const len = b.readUInt16BE(off);\n  off += 2;\n  const payload = b.slice(off, off + len);\n  off += len; // Get response code\n\n  const responseCode = payload.readUInt8(0);\n\n  if (responseCode !== responseCodes.RESP_SUCCESS) {\n    parsed.err = `Error from device: ${responseMsgs[responseCode] ? responseMsgs[responseCode] : 'Unknown Error'}`;\n    parsed.responseCode = responseCode;\n    return parsed;\n  } else {\n    parsed.data = payload.slice(1, payload.length);\n  } // Verify checksum\n\n\n  const cs = b.readUInt32BE(off);\n  const expectedCs = checksum(b.slice(0, b.length - 4));\n\n  if (cs !== expectedCs) {\n    parsed.err = 'Invalid checksum from device response';\n    parsed.data = null;\n    return parsed;\n  }\n\n  return parsed;\n}\n\nfunction checksum(x) {\n  // crc32 returns a signed integer - need to cast it to unsigned\n  // Note that this uses the default 0xedb88320 polynomial\n  return crc32.buf(x) >>> 0; // Need this to be a uint, hence the bit shift\n} // Get a 74-byte padded DER-encoded signature buffer\n// `sig` must be the signature output from elliptic.js\n\n\nfunction toPaddedDER(sig) {\n  // We use 74 as the maximum length of a DER signature. All sigs must\n  // be right-padded with zeros so that this can be a fixed size field\n  const b = Buffer.alloc(74);\n  const ds = Buffer.from(sig.toDER());\n  ds.copy(b);\n  return b;\n} //--------------------------------------------------\n// TRANSACTION UTILS\n//--------------------------------------------------\n\n\nconst signReqResolver = {\n  'BTC': buildBitcoinTxRequest,\n  'ETH': buildEthereumTxRequest,\n  'ETH_MSG': buildEthereumMsgRequest\n}; //--------------------------------------------------\n// CRYPTO UTILS\n//--------------------------------------------------\n\nfunction aes256_encrypt(data, key) {\n  const iv = Buffer.from(AES_IV);\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  const paddedData = data.length % 16 === 0 ? data : aes.padding.pkcs7.pad(data);\n  return Buffer.from(aesCbc.encrypt(paddedData));\n}\n\nfunction aes256_decrypt(data, key) {\n  const iv = Buffer.from(AES_IV);\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  return Buffer.from(aesCbc.decrypt(data));\n} // Decode a DER signature. Returns signature object {r, s } or null if there is an error\n\n\nfunction parseDER(sigBuf) {\n  if (sigBuf[0] !== 0x30 || sigBuf[2] !== 0x02) return null;\n  let off = 3;\n  const sig = {\n    r: null,\n    s: null\n  };\n  const rLen = sigBuf[off];\n  off++;\n  sig.r = sigBuf.slice(off, off + rLen);\n  off += rLen;\n  if (sigBuf[off] !== 0x02) return null;\n  off++;\n  const sLen = sigBuf[off];\n  off++;\n  sig.s = sigBuf.slice(off, off + sLen);\n  return sig;\n}\n\nfunction getP256KeyPair(priv) {\n  return ec.keyFromPrivate(priv, 'hex');\n}\n\nfunction getP256KeyPairFromPub(pub) {\n  return ec.keyFromPublic(pub, 'hex');\n}\n\nmodule.exports = {\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  parseLattice1Response,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  toPaddedDER\n};","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/gridplus-sdk/src/util.js"],"names":["buildBitcoinTxRequest","require","buildEthereumTxRequest","buildEthereumMsgRequest","Buffer","aes","crc32","elliptic","AES_IV","responseCodes","responseMsgs","VERSION_BYTE","EC","ec","parseLattice1Response","r","parsed","err","data","b","from","off","protoVer","readUInt8","msgType","readUInt32BE","len","readUInt16BE","payload","slice","responseCode","RESP_SUCCESS","length","cs","expectedCs","checksum","x","buf","toPaddedDER","sig","alloc","ds","toDER","copy","signReqResolver","aes256_encrypt","key","iv","aesCbc","ModeOfOperation","cbc","paddedData","padding","pkcs7","pad","encrypt","aes256_decrypt","decrypt","parseDER","sigBuf","s","rLen","sLen","getP256KeyPair","priv","keyFromPrivate","getP256KeyPairFromPub","pub","keyFromPublic","module","exports"],"mappings":"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","sourcesContent":["// Static utility functions\nconst { buildBitcoinTxRequest } = require('./bitcoin');\nconst { buildEthereumTxRequest, buildEthereumMsgRequest } = require('./ethereum');\nconst Buffer = require('buffer/').Buffer\nconst aes = require('aes-js');\nconst crc32 = require('crc-32');\nconst elliptic = require('elliptic');\nconst { AES_IV, responseCodes, responseMsgs, VERSION_BYTE } = require('./constants');\nconst EC = elliptic.ec;\nconst ec = new EC('p256');\n\n//--------------------------------------------------\n// LATTICE UTILS\n//--------------------------------------------------\n\n// Parse a response from the Lattice1\nfunction parseLattice1Response(r) {\n  const parsed = {\n    err: null,\n    data: null,\n  }\n  const b = Buffer.from(r, 'hex');\n  let off = 0;\n  \n  // Get protocol version\n  const protoVer = b.readUInt8(off); off++;\n  if (protoVer !== VERSION_BYTE) {\n    parsed.err = 'Incorrect protocol version. Please update your SDK';\n    return parsed;\n  }\n\n  // Get the type of response\n  // Should always be 0x00\n  const msgType = b.readUInt8(off); off++;\n  if (msgType !== 0x00) {\n    parsed.err = 'Incorrect response from Lattice1';\n    return parsed;\n  }\n\n  // Get the payload\n  b.readUInt32BE(off); off+=4; // First 4 bytes is the id, but we don't need that anymore\n  const len = b.readUInt16BE(off); off+=2;\n  const payload = b.slice(off, off+len); off+=len;\n\n  // Get response code\n  const responseCode = payload.readUInt8(0);\n  if (responseCode !== responseCodes.RESP_SUCCESS) {\n    parsed.err = `Error from device: ${responseMsgs[responseCode] ? responseMsgs[responseCode] : 'Unknown Error'}`;\n    parsed.responseCode = responseCode;\n    return parsed;\n  } else {\n    parsed.data = payload.slice(1, payload.length);\n  }\n\n  // Verify checksum\n  const cs = b.readUInt32BE(off);\n  const expectedCs = checksum(b.slice(0, b.length - 4));\n  if (cs !== expectedCs) {\n    parsed.err = 'Invalid checksum from device response'\n    parsed.data = null;\n    return parsed;\n  }\n  \n  return parsed;\n}\n\nfunction checksum(x) {\n  // crc32 returns a signed integer - need to cast it to unsigned\n  // Note that this uses the default 0xedb88320 polynomial\n  return crc32.buf(x) >>> 0; // Need this to be a uint, hence the bit shift\n}\n\n// Get a 74-byte padded DER-encoded signature buffer\n// `sig` must be the signature output from elliptic.js\nfunction toPaddedDER(sig) {\n  // We use 74 as the maximum length of a DER signature. All sigs must\n  // be right-padded with zeros so that this can be a fixed size field\n  const b = Buffer.alloc(74);\n  const ds = Buffer.from(sig.toDER());\n  ds.copy(b);\n  return b;\n}\n\n//--------------------------------------------------\n// TRANSACTION UTILS\n//--------------------------------------------------\nconst signReqResolver = {\n  'BTC': buildBitcoinTxRequest,\n  'ETH': buildEthereumTxRequest,\n  'ETH_MSG': buildEthereumMsgRequest,\n}\n\n//--------------------------------------------------\n// CRYPTO UTILS\n//--------------------------------------------------\nfunction aes256_encrypt(data, key) {\n  const iv = Buffer.from(AES_IV);\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  const paddedData = (data.length) % 16 === 0 ? data : aes.padding.pkcs7.pad(data);\n  return Buffer.from(aesCbc.encrypt(paddedData));\n}\n\nfunction aes256_decrypt(data, key) {\n  const iv = Buffer.from(AES_IV);\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  return Buffer.from(aesCbc.decrypt(data));\n}\n\n// Decode a DER signature. Returns signature object {r, s } or null if there is an error\nfunction parseDER(sigBuf) {\n  if (sigBuf[0] !== 0x30 || sigBuf[2] !== 0x02) return null;\n  let off = 3;\n  const sig = { r: null, s: null }\n  const rLen = sigBuf[off]; off++;\n  sig.r = sigBuf.slice(off, off + rLen); off += rLen\n  if (sigBuf[off] !== 0x02) return null;\n  off++;\n  const sLen = sigBuf[off]; off++;\n  sig.s = sigBuf.slice(off, off + sLen);\n  return sig;\n}\n\nfunction getP256KeyPair (priv) {\n  return ec.keyFromPrivate(priv, 'hex');\n}\n\nfunction getP256KeyPairFromPub(pub) {\n  return ec.keyFromPublic(pub, 'hex');\n}\n\n\nmodule.exports = {\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  parseLattice1Response,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  toPaddedDER,\n}"]},"metadata":{},"sourceType":"script"}